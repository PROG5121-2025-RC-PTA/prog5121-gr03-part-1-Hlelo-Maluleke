import javax.swing.JOptionPane;
import java.util.Random;
import java.io.FileWriter;
import java.io.IOException;
import org.json.JSONObject;

public class Message {
    // Class variables (static)
    private static Random random = new Random(); // Object of Random class to generate random numbers
    private static MessageData[] messages = new MessageData[100]; // Array of MessageData objects to store messages
    private static int messageCount = 0; // Variable to keep track of the number of messages

    // Inner MessageData class
    public static class MessageData {
        // Instance variables
        String senderUsername;
        String messageText;
        int messageNumber;
        String recipientCell;
        private String messageId; // This is the instance variable for the message ID

        // Constructor for the MessageData class
        public MessageData(String messageId, String senderUsername, String messageText, int messageNumber, String recipientCell) {
            this.messageId = messageId; // Assign the provided message ID
            this.senderUsername = senderUsername; // Assign the sender's username
            this.messageText = messageText; // Assign the message text
            this.messageNumber = messageNumber; // Assign the message number
            this.recipientCell = recipientCell; // Assign the recipient cell number
        }
    }

    // Method to generate a unique 10 digit message ID
    public static String generateMessageId() {
        // Generates a unique 10-digit message ID
        long id = random.nextLong() % 10000000000L; // Generate a random long number and apply modulo operator (%) to get a number less than 10000000000
        if (id < 0) { // Use of an if statement (decision) to ensure the number is positive
            id += 10000000000L; // If the number is negative add 10000000000 to make it positive
        }
        return String.valueOf(id); // Convert the long to a String and return it
    }

    // Method to ensure that the message ID is not more than ten characters
    public static boolean checkMessageID(String messageId) {
        // This method ensures that the message ID is not more than ten characters
        return messageId != null && messageId.length() <= 10; // Returns a boolean value
    }

    // Method to ensure that the recipient cell number is no more than ten characters long and starts with the correct prefix
    public static int checkRecipientCell(String recipientCell) {
        // This method ensures that the recipient cell number is no more than ten characters long and starts with correct prefix
        // Returns 1 if valid (registered), 0 if invalid (not registered)
        return Login.isPhoneNumberRegistered(recipientCell) ? 1 : 0;
    }

    // Method to check the message length
    public static boolean checkMessageLength(String messageText) {
        // Checks if the message length is less than 250
        if (messageText != null && messageText.length() < 250) { // Use of an if statement (decision) and the .length() method (String method)
            return true;
        } else {
            return false;
        }
    }

    // Method to allow the user to choose if they want to send, store, or disregard the message
    public static String SentMessage(String username, int numberOfMessages) {
        // This method should allow the user to choose if they want to send, store, or disregard the message
        if (numberOfMessages <= 0) { // Use of an if statement (decision) to check if the number of messages is valid
            JOptionPane.showMessageDialog(null, "Number of messages must be greater than 0.");
            return "Error: Invalid number of messages";
        }

        for (int i = 0; i < numberOfMessages; i++) { // Use of a for loop (iteration) to send multiple messages
            String messageText = JOptionPane.showInputDialog(null, "Enter a message" + (i + 1) + ";"); // Get the message text from the user using JOptionPane, messageText is a String variable
            String recipientCell = JOptionPane.showInputDialog(null, "Enter recipient cell number" + (i + 1) + ";"); // Get the recipient cell number from the user using JOptionPane, recipientCell is a String variable
            if (messageText == null || messageText.trim().isEmpty()) { // Use of an if statement (decision) and the .isEmpty() method (String method)
                JOptionPane.showMessageDialog(null, "Message cannot be empty.");
                i--; // decrement i to re-enter the message
                continue;
            }
            if (checkRecipientCell(recipientCell) == 0) { // Use of an if statement (decision) to check if recipient is invalid
                JOptionPane.showMessageDialog(null, "Recipient number is invalid, message not sent");
                i--;
                continue;
            }
            if (!checkMessageLength(messageText)) { // Use of an if statement (decision) and the ! (not) operator
                JOptionPane.showMessageDialog(null, "Please enter a message of less than 50 characters");
                i--;
                continue;
            }
            String currentMessageId = generateMessageId(); // Generate message ID here (local variable)
            if (!checkMessageID(currentMessageId)) { // Use of an if statement (decision) and the ! (not) operator
                JOptionPane.showMessageDialog(null, "Message ID is invalid");
                i--;
                continue;
            }
            // Use messageCount + 1 for the current message number before incrementing messageCount
            String messageHash = createMessageHash(currentMessageId, messageCount + 1, messageText); // Generate the message hash using the new method
            String choice = JOptionPane.showInputDialog(null, "Enter 'send' to send, 'store' to store, or 'discard' to discard the message:"); // added user choice

            if (choice != null) {
                switch (choice.toLowerCase()) {
                    case "send":
                        // Pass messageCount + 1 as the messageNumber for the constructor
                        messages[messageCount++] = new MessageData(currentMessageId, username, messageText, messageCount, recipientCell); // Store the message in the messages array, messageCount++ is a post-increment operator
                        if (messageCount >= messages.length) { // Use of an if statement (decision) to check if the message buffer is full
                            JOptionPane.showMessageDialog(null, "Message buffer is full");
                            break; // Stop accepting messages
                        }
                        JOptionPane.showMessageDialog(null,
                                "Message sent successfully with Hash: " + messageHash); // display message hash
                        break;
                    case "store":
                        storeMessage(currentMessageId, username, messageText, messageCount + 1, recipientCell); // Pass messageCount + 1
                        JOptionPane.showMessageDialog(null, "Message stored successfully.");
                        break;
                    case "discard":
                        JOptionPane.showMessageDialog(null, "Message discarded.");
                        break;
                    default:
                        JOptionPane.showMessageDialog(null, "Invalid choice. Message discarded.");
                }
            }
        }
        JOptionPane.showMessageDialog(null, "Message sending process completed.");
        return "Message process completed successfully";
    }

    // Method to create and return the Message Hash
    private static String createMessageHash(String messageId, int messageNumber, String messageText) {
        // This method creates and returns the Message Hash
        String[] words = messageText.split("\\s+"); // Split the message into words, words is a String array
        String firstWord = words.length > 0 ? words[0] : ""; // Get the first word
        String lastWord = words.length > 0 ? words[words.length - 1] : ""; // Get the last word
        String hash = String.format("%02d:%d:%s%s", // Use String.format to format the hash
                Integer.parseInt(messageId.substring(0, 2)), // Get the first two digits of the message ID using substring and convert it to an Integer using Integer.parseInt()
                messageNumber,
                firstWord.toUpperCase(), // Convert the first word to uppercase using toUpperCase() (String method)
                lastWord.toUpperCase()); // Convert the last word to uppercase using toUpperCase() (String method)
        return hash; // Return the generated hash
    }

    // Method to store the messages in JSON
    private static void storeMessage(String messageId, String username, String messageText, int messageNumber, String recipientCell) {
        // Use this method to store the messages in JSON
        JSONObject messageJson = new JSONObject(); // Create a new JSONObject to store the message data
        messageJson.put("messageId", messageId); // Store the message ID
        messageJson.put("username", username); // Store the username
        messageJson.put("messageText", messageText); // Store the message text
        messageJson.put("messageNumber", messageNumber); // Store the message number
        messageJson.put("recipientCell", recipientCell); // Store the recipient cell

        try (FileWriter fileWriter = new FileWriter("stored_messages.json", true)) { // Use try-with-resources to automatically close the file
            fileWriter.write(messageJson.toString() + System.lineSeparator()); // Write the JSON object to the file, followed by a newline character
        } catch (IOException e) { // Catch any potential IOException
            JOptionPane.showMessageDialog(null, "Error storing message: " + e.getMessage()); // Display an error message
        }
    }

    // Method to return a list of all the messages sent while the program is running
    public static String printMessages() {
        // This method returns a list of all the messages sent while the program is running
        if (messageCount == 0) {
            return "No messages sent yet.";
        }
        StringBuilder sb = new StringBuilder("List of all messages:\n");
        for (int i = 0; i < messageCount; i++) {
            if (messages[i] != null) {
                sb.append("Message ID: ").append(messages[i].messageId).append("\n");
                sb.append("Sender: ").append(messages[i].senderUsername).append("\n");
                sb.append("Text: ").append(messages[i].messageText).append("\n");
                sb.append("Number: ").append(messages[i].messageNumber).append("\n");
                sb.append("Recipient: ").append(messages[i].recipientCell).append("\n\n");
            }
        }
        return sb.toString();
    }

    // Method to return the total number of messages sent
    public static int returnTotalMessages() {
        // This method returns the total number of messages sent
        return messageCount;
    }
}